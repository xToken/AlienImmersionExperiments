// ======= Copyright (c) 2003-2011, Unknown Worlds Entertainment, Inc. All rights reserved. =======
//
// lua\Infestation.lua
//
//    Created by:   Andreas Urwalek (andi@unknownworlds.com)
//
//    Patch of infestation generated by hives or cysts.
//
// ========= For more information, visit us at http://www.unknownworlds.com =====================

PrecacheAsset("materials/infestation/infestation_decal.surface_shader")
PrecacheAsset("materials/infestation/infestation_shell.surface_shader")
PrecacheAsset("materials/infestation/Infestation.surface_shader")
PrecacheAsset("models/alien/infestation/infestation_shell.model")
PrecacheAsset("models/alien/infestation/infestation_blob.model")

Script.Load("lua/InfestationCache.lua")

local kInfestationDecalMaterial = PrecacheAsset("materials/infestation/infestation_decal.material")
local kInfestationDecalSimpleMaterial = PrecacheAsset("materials/infestation/infestation_decal_simple.material")

local kInfestation = {}
local kDirtyTable = {}
local kInfestationBlobCount = 0
local kInfestationBlobDepth = 1
local kInfestationBlobDecals = 0
local kInfestationOverhead = false

//Globals?
gInfestationMaxDepth = 1
gInfestationMaxBlobs = 100
gInfestationMaxDecals = 50

class 'Infestation'

local kMaxRadius = kInfestationRadius

function CreateStructureInfestation(parent, coords, teamNumber, infestationRadius, blobMultiplier)

    local infestation = Infestation()
    infestation:Initialize()
    infestation:SetCoords(coords)    
    infestation:SetMaxRadius(infestationRadius)
    infestation:SetBlobMultiplier(blobMultiplier)
	infestation.parentclassname = parent:GetClassName()
    
    return infestation
    
end

local function DestroyClientGeometry(self)

    if self.infestationModelArray ~= nil then
        Client.DestroyRenderModelArray(self.infestationModelArray)
        self.infestationModelArray = nil
    end

    if self.infestationShellModelArray ~= nil then
        Client.DestroyRenderModelArray(self.infestationShellModelArray)
        self.infestationShellModelArray = nil
    end
    
    if self.infestationDecals ~= nil then
        for i=1,#self.infestationDecals do
            Client.DestroyRenderDecal(self.infestationDecals[i])
        end
        self.infestationDecals = nil
    end
	
	if self.infestationMaterials ~= nil then
        for i=1,#self.infestationMaterials do
            Client.DestroyRenderMaterial(self.infestationMaterials[i])
        end
        self.infestationMaterials = nil
    end
  
    self.hasClientGeometry = false

end


function CreateInfestationModelArray(modelName, blobCoords, origin, radiusScale, radiusScale2 )

    local modelArray = nil
    
    if #blobCoords > 0 then
            
        local coordsArray = { }
        local numModels = 0
        
        for index, coords in ipairs(blobCoords) do

			if numModels >= kInfestationBlobCount then
				break
			end
			
            local c  = Coords()
            c.xAxis  = coords.xAxis  * radiusScale
            c.yAxis  = coords.yAxis  * radiusScale2
            c.zAxis  = coords.zAxis  * radiusScale
            c.origin = coords.origin - coords.yAxis * 0.3
            
            numModels = numModels + 1
            coordsArray[numModels] = c
            
        end
        
        if numModels > 0 then

            modelArray = Client.CreateRenderModelArray(RenderScene.Zone_Default, numModels)
            modelArray:SetCastsShadows(false)
            modelArray:InstanceMaterials()

            modelArray:SetModel(modelName)
            modelArray:SetModels( coordsArray )

        end
        
    end
    
    return modelArray

end

function CreateModelArrays(self)
    
    // Make blobs on the ground thinner to so that Skulks and buildings aren't
    // obscured.
    local scale = self.blobDepth
    if self.coords.yAxis.y > 0.5 then
        scale = scale * 0.75
    end
    
    local origin = self.coords.origin

    self.infestationModelArray = CreateInfestationModelArray( "models/alien/infestation/infestation_blob.model", self.blobCoords, origin, 1, 1 * scale )
    self.infestationShellModelArray = CreateInfestationModelArray( "models/alien/infestation/infestation_shell.model", self.blobCoords, origin, 1.75, 1.25 * scale )
    
end

local function CreateDecals(self)

    local decals = { }
	local materials = { }
	local materialsIndex = 0
    
    for index, coords in ipairs(self.blobCoords) do
	
        local decal = Client.CreateRenderDecal()
		
		if self.coords.yAxis.y > 0.5 or kInfestationBlobDecals == 0 then
		
			decal:SetMaterial(self.infestationMaterial)		
			decal:SetExtents(Vector(1.5, 0.1, 1.5))
			
		elseif materialsIndex <= kInfestationBlobDecals then
		
			local infestationMaterial = Client.CreateRenderMaterial()
			infestationMaterial:SetMaterial(kInfestationDecalSimpleMaterial)
			infestationMaterial:SetParameter("scale", 1)
		    decal:SetMaterial(infestationMaterial)
			materials[materialsIndex] = infestationMaterial
			materialsIndex = materialsIndex + 1
			decal:SetExtents(Vector(2, 2, 2))
		end
		
        decal:SetCoords(coords)		
        decals[index] = decal		
        
    end

    self.infestationDecals = decals
	self.infestationMaterials = materials
	
end

local function CreateClientGeometry(self)

	self.blobCount = kInfestationBlobCount
	self.blobDepth = kInfestationBlobDepth
	self.decalCount = kInfestationBlobDecals
	
    CreateModelArrays(self)
    CreateDecals(self)
	
    self.hasClientGeometry = true
    
end

function Infestation:Initialize()

    self.radius = 0
    self.lastRadius = 0
    self.cloakFraction = 0
    self.lastCloakFraction = 0
    self.visible = false
    self.blobMultiplier = 1
    
    self.maxRadius = kMaxRadius
    self.blobCoords = { }
	
	if Client then
    
        self.infestationMaterial = Client.CreateRenderMaterial()
        self.infestationMaterial:SetMaterial(kInfestationDecalMaterial)
    
    end
    
    self.destroyed = false
    
    table.insertunique(kDirtyTable, self)
    table.insert(kInfestation, self)
 
end

function Infestation:Uninitialize()

    if Client then
    
        DestroyClientGeometry(self)
		
		if self.infestationMaterial then
        
            Client.DestroyRenderMaterial(self.infestationMaterial)
            self.infestationMaterial = nil
        
        end
        
        self.destroyed = true
    
    end
    
    table.removevalue(kInfestation, self)
    
end

function Infestation:SetBlobMultiplier(multiplier)
    self.blobMultiplier = multiplier
end

function Infestation:SetIsVisible(visible)

    if self.visible ~= visible then
        
        table.insertunique(kDirtyTable, self)
        self.visible = visible
        
    end

end

function Infestation:GetIsVisible()
    return self.visible
end

function Infestation:SetCoords(coords)
    self.coords = Coords(coords)
    table.insertunique(kDirtyTable, self)
end

function Infestation:GetCoords()
    return self.coords
end

function Infestation:GetRadius()    
    return self.radius    
end

function Infestation:SetRadius(radius)

    if self.radius ~= radius then

        self.radius = radius
        table.insertunique(kDirtyTable, self)
    
    end
    
end

function Infestation:SetCloakFraction(cloakFraction)

    if self.cloakFraction ~= cloakFraction then
        
        self.cloakFraction = cloakFraction
        
        // this change is not interesting for the server
        if Client then
            table.insertunique(kDirtyTable, self)
        end
    
    end

end

function Infestation:SetMaxRadius(radius)
    self.maxRadius = radius
end

function Infestation:GetMaxRadius()
    return self.maxRadius
end

function Infestation:GenerateBlobs()

    assert(self.coords)
    
    // generate the blobs, use cached blobs if exist
    table.copy(gInfestationCache:GetBlobCoords(self), self.blobCoords)
    
end

// only called when the infestation actually changed
function Infestation:RenderInfestation(generateBlobs)

    PROFILE("Infestation:RenderInfestation")
    
    if #self.blobCoords == 0 then
    
        if generateBlobs then
            self:GenerateBlobs()
        else
            return false
        end
    
    end
    
    local qualityChanged = (self.blobCount ~= kInfestationBlobCount or self.blobDepth ~= kInfestationBlobDepth or self.decalCount ~= kInfestationBlobDecals)
    
    if qualityChanged then
        DestroyClientGeometry(self)
    end

    if not self.hasClientGeometry and self.visible then
        CreateClientGeometry(self)
    elseif self.hasClientGeometry and not self.visible then
        DestroyClientGeometry(self)
    end

    local origin = self.coords.origin
    local amount = self.maxRadius > 0 and self.radius / self.maxRadius or 0
    
    // Apply cloaking effects.
    amount = amount * (1 - self.cloakFraction)
    
    if self.infestationModelArray then
    
		self.infestationModelArray:SetMaterialParameter("amount", amount)
		self.infestationModelArray:SetMaterialParameter("origin", origin)
		self.infestationModelArray:SetMaterialParameter("maxRadius", self.maxRadius)
		
		self.infestationShellModelArray:SetMaterialParameter("amount", amount)
		self.infestationShellModelArray:SetMaterialParameter("origin", origin)
		self.infestationShellModelArray:SetMaterialParameter("maxRadius", self.maxRadius)
		
	end
	
	self.infestationMaterial:SetParameter("amount", amount)
	self.infestationMaterial:SetParameter("origin", origin)
	self.infestationMaterial:SetParameter("maxRadius", self.maxRadius)

end

// only called when the infestation actually changed
function Infestation:UpdateInfestables()

    PROFILE("Infestation:UpdateInfestables")

    local entityIds = {}
    local smallestRadius = self.radius
    local biggestRadius = self.lastRadius
    // point is guaranteed on infestation when growing, only shrinking requires another check
    local onInfestation = self.radius > self.lastRadius

    if smallestRadius > biggestRadius then
        smallestRadius, biggestRadius = biggestRadius, smallestRadius
    end
    
    local origin = self.coords.origin
    for index, entity in ipairs(GetEntitiesWithMixinWithinRange("InfestationTracker", self.coords.origin, biggestRadius)) do
    
        local range = (origin - entity:GetOrigin()):GetLength()
        if range >= smallestRadius and range <= biggestRadius then
            entity:UpdateInfestedState(onInfestation)
        end
        
    end

end

function Infestation:GetIsPointOnInfestation(point)

    local onInfestation = false
    
    // Check radius
    local radius = point:GetDistanceTo(self.coords.origin)
    if radius <= self:GetRadius() then
    
        // Check dot product
        local toPoint = point - self.coords.origin
        local verticalProjection = math.abs( self.coords.yAxis:DotProduct( toPoint ) )
        
        onInfestation = (verticalProjection < 1)
        
    end
    
    return onInfestation
   
end

if Server then
	
	local function UpdateDirtyTable()

		PROFILE("Infestation:UpdateDirtyTable")
		
		for i = 1, #kDirtyTable do
		
			local infestation = kDirtyTable[i]
		
			if not infestation.destroyed then
			
				infestation:UpdateInfestables()
				
				infestation.lastRadius = infestation.radius
				infestation.lastCloakFraction = infestation.cloakFraction
			
			end
		
		end
		
		kDirtyTable = {}

	end

    Event.Hook("UpdateServer", UpdateDirtyTable)
	
elseif Client then

	local kUpdatesPerFrame = 1
	local function UpdateDirtyTableClient()

		PROFILE("Infestation:UpdateDirtyTableClient")
		
		//DebugPrint("num infestation %s, num dirty %s", ToString(#kInfestation), ToString(#kDirtyTable))

		local remainingUpdates = {}
		local updatesDone = 0
		
		for i = 1, #kDirtyTable do
		
			local infestation = kDirtyTable[i]

			if not infestation.destroyed then
			
				infestation:RenderInfestation(updatesDone < kUpdatesPerFrame)
				
				if updatesDone >= kUpdatesPerFrame then
					// update later to prevent hitches
					table.insert(remainingUpdates, infestation)            
				else
				
					infestation.lastRadius = infestation.radius
					infestation.lastCloakFraction = infestation.cloakFraction
					
					updatesDone = updatesDone + 1
					
				end    
			
			end
		
		end
		
		kDirtyTable = remainingUpdates
		
	end

    Event.Hook("UpdateClient", UpdateDirtyTableClient)

    function Infestation_SyncOptions()
	
		kInfestationBlobCount = Clamp(Client.GetOptionInteger("graphics/infestationBlobCount", 50), 0, gInfestationMaxBlobs)
		kInfestationBlobDepth = Clamp(Client.GetOptionFloat("graphics/infestationBlobDepth", 0.75), 0, gInfestationMaxDepth)
		kInfestationBlobDecals = Clamp(Client.GetOptionInteger("graphics/infestationBlobDepth", 10), 0, gInfestationMaxDecals)
		//Testing
		kInfestationBlobCount = 0
		kInfestationBlobDepth = 1
		kInfestationBlobDecals = 10
		//Might need to always set this to rich?
        Client.SetRenderSetting("infestation", "rich")
        // mark all as dirty to update quality
        table.copy(kInfestation, kDirtyTable)
        
    end
    
    Event.Hook("LoadComplete", Infestation_SyncOptions)
    
    function Infestation_UpdateForPlayer()
        
        // Change the texture scale when we're viewing top down to reduce the
        // tiling and make it look better.
		// This doesnt need to be set EVERY frame does it?... It does..		
		local isOverhead = PlayerUI_IsOverhead()
        if isOverhead then
            Client.SetRenderSetting("infestation_scale", 0.15)
        else
			Client.SetRenderSetting("infestation_scale", 0.30)
        end

    end
	
	local function UpdateInfestationDecals(decals)
		kInfestationBlobDecals = tonumber(decals or 10)
		table.copy(kInfestation, kDirtyTable)
		Shared.Message(string.format("Infestation Decals set to %s", kInfestationBlobDecals))
	end
	
	Event.Hook("Console_infestdecals", UpdateInfestationDecals)
	
	local function UpdateInfestationBlobs(blobs)
		kInfestationBlobCount = tonumber(blobs or 50)
		table.copy(kInfestation, kDirtyTable)
		Shared.Message(string.format("Infestation Blobs set to %s", kInfestationBlobCount))
	end
	
	Event.Hook("Console_infestblobs", UpdateInfestationBlobs)
	
	local function UpdateInfestationDepth(depth)
		kInfestationBlobDepth = tonumber(depth or 1)
		table.copy(kInfestation, kDirtyTable)
		Shared.Message(string.format("Infestation Depth set to %s", kInfestationBlobDepth))
	end
	
	Event.Hook("Console_infestdepth", UpdateInfestationDepth)

end

